I just said we had a concept that test that three types for mergeable. 
so we have a little notation using ??? it says, give me three types that meet this.
and here are the way i'm using these three types.

we just rap the whole thing up and just say, give me a set of types, that meets my requirements.

so that introduce three names in a scope , " For For2 and Out" which will using here.
and it says that once you give me that in a call, I'll execute the predicate "mergeable" on them to see whether it works.

and, that's the way it looks.

obviously, we take three type names, the first one have to be forward iterator, the second one have to be forward iterator too, not necessary the same forward iterator type. and then we have output iterator, we have assignable requirements and comparable requirements. that's it! just the predicate.

so, this sounds very good. we are of course not finished. that is, there are mush more we can do to improve c++. so let me finish off by looking a bit on the challenges that's facing us. 
there are many and complicated. 

those of you who are to take an Ancient Greek knows this is one of the labors Hercules(Heracles).

he is trying to kill a hydra.

very hard task.

so, c++ challenges.
so, we want to make a better languages , and we also want to convince programmers that the new stuff actually works well.

and that's relatively easy for actually getting people to use in large code bases.  but. we first have to improve the languages and then we have convince people that use worth well.

and then we can start seeing the partials of introducing the existing code bases that doesn't have it.

i refer to that as source code rejuvenation, and I think that is going to be an important issue.  
so basically, what ever we do to the language, what ever we do to change the implementation, we can't eliminate the c++ major strength.  introduce to the language

that is a lot of people has a solutions that ends up been worse that the problem for a large number of people.

compatibility is a feature in itself.
that means that ugly things will not go away even when you provide good alternatives. 
we just have to get people to use the good alternatives where they can. 
so compatibility is necessary.

performance, uncompromising , portability where appropriate , and we would like to increase, not restrict, the application areas.

if we could restrict the application ranges, we could be get a ??? language.
but , actually there is a crew by me from about 1984, then even I can decide a ??? language.

that just wasn't the exercise. it was not the aim of those that use by most useful language for more people for more application areas.

and I think that is very well worth pursuing. 

so the challenge is I would like to close more type loopholes, we need to address concurrent programming, we need some thing that's higher level that the threads, locks style programming which is universal necessary, and about the worse way writing concurrency system that I know of.
we need to build libraries that provide higher model. we want to simply generic programming, I'm looking at concepts, we should .. I means some of us have them today, but we need have them all next year. and we want to simply programming using class hierarchies, I've been doing some work on  ..... multiple methods and functional style. em, some of it is available on my homepage, on the publications, and software also available.
but it's the research work, but I hope some of it gets into the language if not now then later.

you have to think in-long-term in this kinds of stuff.
some times, you have to sort of imagine what the world would like in ten years, and try to get there.
I suppose to thinking , oh ,dear, it will take more than a year, I can't do it. the next quarter is essential ..  on  that kind of thing.
we have to have some longer term thinking.

let's see. better support for ... object oriented generic programming .. get back to that. 
but I don't like the way the community some time fold into different and waring camps when they don't have an need to.

we have to support, combinations of programming styles.
we have to make exception usable for real time project.
one of the things I've said about is that exceptions are not used for hard real time, it can be used for soft real time.
and the reason is very simple. it is, we don't have choise that allow us to estimate how long it takes to recover from an error when exception is thrown. the tools don't exist. I want to build it from 5 years ago but somehow I never get around to it.
been an university students . it became too difficult just because it all to be solved.

it has to be publishable  teachable and fashionable . 

but we need to make exceptions more usable. and we have to deal with multiple address spaces eventually.

the notion that everything works in a single address space is ... it's creaking , it's difficult.
we get these big memories with lots of cores lots of things, but they are uniform any more. 
different memories takes different time to use in such way. I think we need to think about that. access.
we want more domain specific libraries, and we want to develop a better specification of c++.
I think English text is.. err, is ,,, maxing out in terms of what we can handle.

finally I just do a little rant.
I really dislike the word paradigms.
it was invented by coon and imply some superiority of one paradigms over another. and thins changes, everything changes, nor the older stuff became bad.


Kristen Nygaard said, you know, addiction didn't actually become useless just because we invented multiplication, nothing was over turned, you incorporate the old stuff, maybe you have to re-phrase the old stuff. newton mechanism just not disappear just because of Einstein, it became special case, actually a very useful special case.
similarly, I would like to see OOP, GE, and conventional programming just as differential aspects that you can use in combinations and I want be able to develop rules for how you do things that doesn't chock in terms of these paradigms which might become semi religions.

and the focus has become language features , do I write templates do I write virtual functions, that incomplete senses.
so I think it makes harms, it makes things complicated, it grades bad code and people write code for instance, they believe object oriented is right, they are write generic code, use interfaces in virtual functions, which is less convince than templates and long much ??

and similarly you can have people that so believing in generic programming that they make everything into statically resolved overloading and they should have build hierarchy and dynamic solution will much simple and easier to debug and document.

so here is an example of what I mean.

I want to draw all elements in a container. And I want that container to have value type that is the type of the element to be pointers to shapes. fine, and then I want to for each elements in the container, I want to call draw.

now, this is the generalization of the classical object oriented programming draw all shapes. that was first on..  way back in 67.. for useful paradigm. before they have screens that could do this kinds of things. so this is an old program. it's obviously object oriented code. also see here, it's clearly hierarchy of shapes. and there's a virtual function that dispatches to the right kinds of shape. this is object oriented code. obviously it's generic, look , it is parametrized on the kinds of container and you want to do the same to ..  element type ..to that ... and you call for_each algorithm. cleanly cleanly it's generic programming. but it's also very ordinary programming, I just want to draw everything in a container. and I just call a couple of functions on them. it happens to be a lambda, but .. hey, it's just a peace of code that called.

so, I don't believe that you can creditably claim that this one is one and not the other two. it's all three and integrate rather nicely, we have to work on this integration. 

ok, we reach the Q&A time, and .. I'm not sure.. do we have some microphones that people can use? because I barely see people in the back, I certainly can't hear you out there.

so any questions?

this one up there. ah.
