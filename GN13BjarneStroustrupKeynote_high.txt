so here is actual error message from this code. list<int> does not satisfy the constraint 'sortable'. and if you hit, oh . ( in response to applause ) Thank You.

by the way, if you hit another compile option, it will tell you why list is not sortable.
it will come back and tell you .... that it couldn't  ... it it it doesn't know where the scrap ???

but that's .. that's ... en... I like the short version and who likes the longer version.

the shorthand notation is if you don't want to write all of these require stuff, you come upset you can actually write, we need a sequence S, for which the value type of the sequence is equality comparable to the other template argument T. and we can say  iterator T find  ... well.
some people like this notations some people like the others.

you have a choice. (和前面说 template syntax 没有选择呼应了。)

this is just the shorthand. it expand to the required version.

and we can handle essentially all of the Palo Alto technical report.
Palo Alto technical report is a hundred sum page of document specify every algorithm in the STL and this was done by a group of about twenty people in parallel in two years ago. Jon (Jon Kalb) was there, I was there. it was called by Andrew Lumsdaine from Indiana (University ), which is one of the main workers of c++0x concept. and got Alex Stepanov, who is the father of STL , to chair it, and we spend a week, simple specify everything.

so, first, you figure out what you want, and then you figure out how design a language which will do it. that's the right way around ( PS: 他在说 java/go/c# 这种领导拍屁股想出来的语言么？)

don't go and look for fancy language features and see how can can use them.
this idea, that you look for problems that fit your tool is wrong.  so we did the other way around.
all of the work on concept lite is done on applications and find how we can support it.
and we don't have the semantic parts, because , we consider that ... would be too much to handle just now. we don't see problems that checking template(definition) in isolation but we don't do it. that is, we check the use of a template , if a template specify to require something, we assume that the implementation will stick to that contract. we don't actually verify it. we think it can be verified bu you have to be very careful.

those of you who has ... words with strict functional languages like haskell, we know it's really hard to debug, because you made slight change to the implementation, like insert the extern model printf, the interface change, and every thing has to change.  that is painful. 

we didn't want to go that, we need more word experience before we standardized something like that. and we actual use require that much.

overloading is fairly easy. we have two versions of find, one for sequences and one for associative container. if I take a vector or multiset, I try to find something in the vector, it will find the first overload and go and search along. for the second one, it will notice that multiset is an associative container, it will pick the second one , and it will do the search in the associative container, which is certainly not a liner search through it. that works.

and if you look at it, the overloading is based on predicates.
that means, we don't have a notion of a hierarchy refinement  thing. we simply take the predicates, flap them out as boolean expression, see which boolean expression is subset of t other. if it does, we have refinement relation. if not , we just see what works. if it calls one function and not the other, that's fine. if it calls, it can call two, we pick the more specialized one, if we can call two, an they are not specialization of each other, it's an ambiguity error . that's the whole set or rules.

it's just, do event diagram, that ont that ont and that one , finished.

so we compute what the ambiguity resolution it suppose to be, and the classic example here.
we take advance. here is advance that take an input iterator,  here is advance that take a bidirectional iterator, and here is advance that take a random access iterator,  

the are implemented differently. and we are quite capable of piking the right one in all cases.

ok, how did we define it? well that just bool expression so you write bool expressions, bool expressions get tedious so you write functions that are return booleans, this all work in.

to help you write, there is "required(expression)" that takes a expression, if it is valid expression then return true, if not, it just return false. this will suppose to be implementation details, but everybody scream, they want it,  so this not part of the technical specification.

and to recognize them syntactically, I will show you why we need to do that, we call them concept rather than constexpr. we simply take the work constexpr out, and put concept in.
so that they are the same thing except for the syntax analyzer.

how do we get to sort a container? basically, it's a terse notation what I call it.
it means, sorting a container means sorting a type that meets the container requirements.
and that again means give me a type, check the containers requirements on it, and use that type as argument.

so basically these three ?? I use the underscore underscore to show that it's actually not a 
.. it'a generated name that you can't actually refer to. but this is equivalent. 

so if you like to write out the longhand yourself, you will write something like this.

it will assert that it's a container. and we do the stuff. 
so, this is part of this idea of making simple things simple.

this is the simplest algorithms work really nicely for this ?? .
and it looks just like our traditional functions. 
so sort , sorts, no .. sorry, 
square root, take a square root (sqrt) of something that can behave like a double. and include integers.
basically it equals  (  think of the sort function .. no no no ) (that) the square root function has been specified with the predicate that it's argument has be able to behave like a double.

so, we do the same thing more general, with  sort, it requires something that can behave like a container. and we have these predicate for testing it.

now we back to where I want it to be.
here sqrt doubles, this works, it doesn't. sort containers  , this works, and this doesn't
and we get one liner message there.

so, we can start thinking about generic function exactly like other functions, and you know they look like other functions.

now going form the simplest cases to the the more complicated one.
lets see that this actually how well handle the complicated one here. 

here is merge.

it's a .. yeah, it's merge, right there.

it's pretty ugly. it has given many people headaches, including me. if you think that's too easy, try accumulate(). it's even worse.

so we need to get this stuff under control. we look that's just too ugly , too easy to make mistakes, too repetitive , ah, not good enough. so let's try simplify it a bit.

we can say forward iterator for , forward iterator as the shorthand, and we use one requires that predicates these three and check the connections between them. for complicated algorithm that take many arguments, very often you have predicates that takes all of these arguments and works some relation between them. it's a matter fact, i don't think you'll have a good algorithm where there was no relationship at all. at least it's rare and these domain.

and so, this is quite readable, and we are try to attack this problem. if that's your solution, we know what your problem is. you have to simplify. we can simplify even further.

I just said we had a concept that test that three types for mergeable. 
so we have a little notation using ??? it says, give me three types that meet this.
and here are the way i'm using these three types.

we just rap the whole thing up and just say, give me a set of types, that meets my requirements.

so that introduce three names in a scope , " For For2 and Out" which will using here.
and it says that once you give me that in a call, I'll execute the predicate "mergeable" on them to see whether it works.

and, that's the way it looks.

obviously, we take three type names, the first one have to be forward iterator, the second one have to be forward iterator too, not necessary the same forward iterator type. and then we have output iterator, we have assignable requirements and comparable requirements. that's it! just the predicate.

so, this sounds very good. we are of course not finished. that is, there are mush more we can do to improve c++. so let me finish off by looking a bit on the challenges that's facing us. 
there are many and complicated. 

those of you who are to take an Ancient Greek knows this is one of the labors Hercules(Heracles).

he is trying to kill a hydra.

very hard task.

so, c++ challenges.
so, we want to make a better languages , and we also want to convince programmers that the new stuff actually works well.

and that's relatively easy for actually getting people to use in large code bases.  but. we first have to improve the languages and then we have convince people that use worth well.

and then we can start seeing the partials of introducing the existing code bases that doesn't have it.

i refer to that as source code rejuvenation, and I think that is going to be an important issue.  
so basically, what ever we do to the language, what ever we do to change the implementation, we can't eliminate the c++ major strength.  introduce to the language

that is a lot of people has a solutions that ends up been worse that the problem for a large number of people.

compatibility is a feature in itself.
that means that ugly things will not go away even when you provide good alternatives. 
we just have to get people to use the good alternatives where they can. 
so compatibility is necessary.

performance, uncompromising , portability where appropriate , and we would like to increase, not restrict, the application areas.

if we could restrict the application ranges, we could be get a ??? language.
but , actually there is a crew by me from about 1984, then even I can decide a ??? language.

that just wasn't the exercise. it was not the aim of those that use by most useful language for more people for more application areas.

and I think that is very well worth pursuing. 

so the challenge is I would like to close more type loopholes, we need to address concurrent programming, we need some thing that's higher level that the threads, locks style programming which is universal necessary, and about the worse way writing concurrency system that I know of.
we need to build libraries that provide higher model. we want to simply generic programming, I'm looking at concepts, we should .. I means some of us have them today, but we need have them all next year. and we want to simply programming using class hierarchies, I've been doing some work on  ..... multiple methods and functional style. em, some of it is available on my homepage, on the publications, and software also available.
but it's the research work, but I hope some of it gets into the language if not now then later.

you have to think in-long-term in this kinds of stuff.
some times, you have to sort of imagine what the world would like in ten years, and try to get there.
I suppose to thinking , oh ,dear, it will take more than a year, I can't do it. the next quarter is essential ..  on  that kind of thing.
we have to have some longer term thinking.

let's see. better support for ... object oriented generic programming .. get back to that. 
but I don't like the way the community some time fold into different and waring camps when they don't have an need to.

we have to support, combinations of programming styles.
we have to make exception usable for real time project.
one of the things I've said about is that exceptions are not used for hard real time, it can be used for soft real time.
and the reason is very simple. it is, we don't have choise that allow us to estimate how long it takes to recover from an error when exception is thrown. the tools don't exist. I want to build it from 5 years ago but somehow I never get around to it.
been an university students . it became too difficult just because it all to be solved.

it has to be publishable  teachable and fashionable . 

but we need to make exceptions more usable. and we have to deal with multiple address spaces eventually.

the notion that everything works in a single address space is ... it's creaking , it's difficult.
we get these big memories with lots of cores lots of things, but they are uniform any more. 
different memories takes different time to use in such way. I think we need to think about that. access.
we want more domain specific libraries, and we want to develop a better specification of c++.
I think English text is.. err, is ,,, maxing out in terms of what we can handle.

finally I just do a little rant.
I really dislike the word paradigms.
it was invented by coon and imply some superiority of one paradigms over another. and thins changes, everything changes, nor the older stuff became bad.


Kristen Nygaard said, you know, addiction didn't actually become useless just because we invented multiplication, nothing was over turned, you incorporate the old stuff, maybe you have to re-phrase the old stuff. newton mechanism just not disappear just because of Einstein, it became special case, actually a very useful special case.
similarly, I would like to see OOP, GE, and conventional programming just as differential aspects that you can use in combinations and I want be able to develop rules for how you do things that doesn't chock in terms of these paradigms which might become semi religions.

and the focus has become language features , do I write templates do I write virtual functions, that incomplete senses.
so I think it makes harms, it makes things complicated, it grades bad code and people write code for instance, they believe object oriented is right, they are write generic code, use interfaces in virtual functions, which is less convince than templates and long much ??

and similarly you can have people that so believing in generic programming that they make everything into statically resolved overloading and they should have build hierarchy and dynamic solution will much simple and easier to debug and document.

so here is an example of what I mean.

I want to draw all elements in a container. And I want that container to have value type that is the type of the element to be pointers to shapes. fine, and then I want to for each elements in the container, I want to call draw.

now, this is the generalization of the classical object oriented programming draw all shapes. that was first on..  way back in 67.. for useful paradigm. before they have screens that could do this kinds of things. so this is an old program. it's obviously object oriented code. also see here, it's clearly hierarchy of shapes. and there's a virtual function that dispatches to the right kinds of shape. this is object oriented code. obviously it's generic, look , it is parametrized on the kinds of container and you want to do the same to ..  element type ..to that ... and you call for_each algorithm. cleanly cleanly it's generic programming. but it's also very ordinary programming, I just want to draw everything in a container. and I just call a couple of functions on them. it happens to be a lambda, but .. hey, it's just a peace of code that called.

so, I don't believe that you can creditably claim that this one is one and not the other two. it's all three and integrate rather nicely, we have to work on this integration. 

ok, we reach the Q&A time, and .. I'm not sure.. do we have some microphones that people can use? because I barely see people in the back, I certainly can't hear you out there.

so any questions?

this one up there. ah.
