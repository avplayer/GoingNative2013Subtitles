

but we need to make exceptions more usable. and we have to deal with multiple address spaces eventually.

the notion that everything works in a single address space is ... it's creaking , it's difficult.
we get these big memories with lots of cores lots of things, but they are uniform any more. 
different memories takes different time to use in such way. I think we need to think about that. access.
we want more domain specific libraries, and we want to develop a better specification of c++.
I think English text is.. err, is ,,, maxing out in terms of what we can handle.

finally I just do a little rant.
I really dislike the word paradigms.
it was invented by coon and imply some superiority of one paradigms over another. and thins changes, everything changes, nor the older stuff became bad.


Kristen Nygaard said, you know, addiction didn't actually become useless just because we invented multiplication, nothing was over turned, you incorporate the old stuff, maybe you have to re-phrase the old stuff. newton mechanism just not disappear just because of Einstein, it became special case, actually a very useful special case.
similarly, I would like to see OOP, GE, and conventional programming just as differential aspects that you can use in combinations and I want be able to develop rules for how you do things that doesn't chock in terms of these paradigms which might become semi religions.

and the focus has become language features , do I write templates do I write virtual functions, that incomplete senses.
so I think it makes harms, it makes things complicated, it grades bad code and people write code for instance, they believe object oriented is right, they are write generic code, use interfaces in virtual functions, which is less convince than templates and long much ??

and similarly you can have people that so believing in generic programming that they make everything into statically resolved overloading and they should have build hierarchy and dynamic solution will much simple and easier to debug and document.

so here is an example of what I mean.

I want to draw all elements in a container. And I want that container to have value type that is the type of the element to be pointers to shapes. fine, and then I want to for each elements in the container, I want to call draw.

now, this is the generalization of the classical object oriented programming draw all shapes. that was first on..  way back in 67.. for useful paradigm. before they have screens that could do this kinds of things. so this is an old program. it's obviously object oriented code. also see here, it's clearly hierarchy of shapes. and there's a virtual function that dispatches to the right kinds of shape. this is object oriented code. obviously it's generic, look , it is parametrized on the kinds of container and you want to do the same to ..  element type ..to that ... and you call for_each algorithm. cleanly cleanly it's generic programming. but it's also very ordinary programming, I just want to draw everything in a container. and I just call a couple of functions on them. it happens to be a lambda, but .. hey, it's just a peace of code that called.

so, I don't believe that you can creditably claim that this one is one and not the other two. it's all three and integrate rather nicely, we have to work on this integration. 

ok, we reach the Q&A time, and .. I'm not sure.. do we have some microphones that people can use? because I barely see people in the back, I certainly can't hear you out there.

so any questions?

this one up there. ah.
